str(alist[[1]])
alist <- list(c("a", "b", "c"), c(1,2,3,4), c(8e6, 5.2e9, -9.3e7))
str(alist[[1]])
str(alist[1])
alist[[1]]
alist[1]
alist[[1]]
alist[1]
lst <- list('one','two','three')
a <- lst[1]
class(a)
a <- lst[[1]]
class(a)
lst[[2]]
lst[1]
lst[[1]]
A = matrix(c(2,4,1,5,7),nrows=2,ncol=3,byrow=TRUE)
A = matrix(c(2,4,3,1,5,7),nrows=2,ncol=3,byrow=TRUE)
A = matrix(c(2,4,3,1,5,7),nrow=2,ncol=3,byrow=TRUE)
print(A)
A[[1]]
A[1]
A[,1]
A[[,1]]
A[[1]]
print(A)
A[[4]]
A[[6]]
A[,1]
assign("z", 5)
z
assign("finch",2, envir=birds)
assign("finch",2, envir=bird)
help(which)
sum(3,2)
`+`(3,2)
y <- 3
print(yy)
`<-`(yy,3) # infix
print(yy)
print(read.table)
sum(3,2)
print(sum)
sum()
HardyWeinberg <- function(p=runif(1)) {
q <- 1 - p
fAA <- p^2
fAB <- 2*p*q
fBB <- q^2
vecOut <- signif(c(p=p,AA=fAA,AB=fAB,BB=fBB),digits=3)
return(vecOut)
}
HardyWeinberg <- function(p=runif(1)) {
q <- 1 - p
fAA <- p^2
fAB <- 2*p*q
fBB <- q^2
vecOut <- signif(c(p=p,AA=fAA,AB=fAB,BB=fBB),digits=3)
return(vecOut)
}
View(HardyWeinberg)
HardWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardWeinberg()
HardWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardWeinberg()
HardWeinberg()
HardWeinberg()
HardWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardWeinberg()
HardWeinberg()
HardWeinberg()
HardWeinberg()
HardWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
HardyWeinberg()
pp <- 0.7
HardyWeinberg(pp)
HardyWeinberg(1.2)
HardyWeinberg2 <- function(p=runif(1)) {
if(p > 1.0 | p < 0.0) {
return("Function failure: p must be >=0 and <=1")
}
q <- 1 - p
fAA <- p^2
fAB <- 2*p*q
fBB <- q^2
vecOut <- signif(c(p=p,AA=fAA,AB=fAB,BB=fBB),digits=3)
return(vecOut)
}
HardyWeinberg2(1.2)
sum()
print(sum)
HardyWeinberg2()
HardyWeinberg2(1.2)
HardyWeinberg2(0.5)
HardyWeinberg2(1.2)
z <- HardyWeinberg2(1.2)
print(z)
HardyWeinberg3(1.2)
HardyWeinberg3 <- function(p=runif(1)) {
if(p > 1.0 | p < 0.0) {
stop("Function failure: p must be >=0 and <=1")
}
q <- 1 - p
fAA <- p^2
fAB <- 2*p*q
fBB <- q^2
vecOut <- signif(c(p=p,AA=fAA,AB=fAB,BB=fBB),digits=3)
return(vecOut)
}
HardyWeinberg3(1.2)
z <- HardyWeinberg3(1.2)
myFunc <- function(a=3,b=4) {
z <- a + b
return(z)
}
myFunc()
print(z)
print(a)
myFuncBad <- function(a=3) {
z <- a + b
return(z)
}
myfuncBad()
b <- 10
myfuncBad()
b <- 10
myfuncBad()
myFuncBad <- function(a=3) {
z <- a + b
return(z)
}
b <- 10
myFuncBad()
myFuncBad() # function fails because b is not assigned
myFuncOK <- function(a=3) {
bb <- 100
z <- a + bb
return(z)
}
myFuncOK()
fitLinear <- function(x=runif(10),y=runif(10)){
myMod <- lm(y~x)
myOut <- c(slope=summary(myMod)$coefficients[2,1],
pvalue=summary(myMod)$coefficients[2,4])
plot(x=x,y=y)
return(myOut)
}
fitLinear()
library(ggmap)
install.packages("ggmap")
install.packages("ggplot2")
library(ggmap)
library(ggplot2)
Vtmap<-get_map(location=c(-72.6954,44.127),zoom=5, source="google",maptype="terrain")
ggmap(vtMap)
vtmap<-get_map(location=c(-72.6954,44.127),zoom=5, source="google",maptype="terrain")
ggmap(vtMap)
library(ggmap)
library(ggplot2)
vtmap<-get_map(location=c(-72.6954,44.127),zoom=5, source="google",maptype="terrain")
ggmap(vtMap)
library(ggmap)
library(ggplot2)
vtMap<-get_map(location=c(-72.6954,44.127),zoom=5, source="google",maptype="terrain")
ggmap(vtMap)
get_map(location = c(lon = -72.695461, lat = 44.127084), zoom = "auto", scale = "auto", maptype = c("terrain", "terrain-background", "satellite", "roadmap", "hybrid", "toner", "watercolor", "terrain-labels", "terrain-lines", "toner-2010", "toner-2011", "toner-background", "toner-hybrid", "toner-labels", "toner-lines", "toner-lite"), source = c("google", "osm", "stamen", "cloudmade"), force = ifelse(source == "google", TRUE, TRUE), messaging = FALSE, urlonly = FALSE, filename = "ggmapTemp", crop = TRUE, color = c("color", "bw"), language = "en-EN", api_key)
vtMap <- get_map(location = c(lon = -72.695461, lat = 44.127084), zoom = "auto", scale = "auto", source = "google", TRUE, TRUE)
vtMap <- get_map(location = c(lon = -72.695461, lat = 44.127084), zoom = "auto", scale = "auto", source = "google")
ggmap(vtMap)
vtMap
ggmap(vtMap)
map(vtMap)
install.packages("maps")
library(ggmap)
library(ggplot2)
vtMap<-get_map(location=c(-72.6954,44.127),zoom="auto", scale="auto", source="google",maptype="terrain")
vtMap
vtMap<-get_map(location=c(-72.6954,44.127),zoom="auto", scale="auto", source="google",maptype="terrain")
ggmap(vtMap)
install.packages("ggproto")
install.packages("ggmap", type = "source")
install.packages("ggmap", type = "source")
.75*350
ls()
rm(list=ls())
#Set Working Directory:
setwd("~/AlgerProjects/2015_Bombus_Survey/CSV_Files")
#install package for Morans.i
install.packages(ape)
# get programs
library(ape)
library(plyr)
library(dplyr)
# read in data:
SurvData <- read.csv("MixedModelDF.csv", header=TRUE, sep = ",", stringsAsFactors=FALSE)
SpatialData <- read.csv("2015SurveyLocations.csv", header=TRUE, sep = ",", stringsAsFactors=FALSE)
head(SurvData)
head(SpatialData)
#merge the two datafiles by Site name
SpatialData <- merge(SurvData,SpatialData, by="site")
#Split by viruses
SpatDWV <- subset(SpatialData, target_name=="DWV")
SpatBQ <- subset(SpatialData, target_name=="BQCV")
#not normal! so log transform each one
#DWV:
hist(SpatDWV$BombPrev)
hist(SpatBQ$BombPrev)
SpatDWV$logPrev <- log(SpatDWV$BombPrev)
SpatDWV
hist(SpatDWV$logPrev)
SpatDWV$logPrev[SpatDWV$logPrev == "-Inf"] <- 0
SpatDWV
hist(SpatDWV$logPrev)
#BQCV
hist(SpatDWV$BombPrev)
hist(SpatBQ$BombPrev)
SpatBQ$logPrev <- (SpatBQ$BombPrev)^3
SpatBQ
hist(SpatBQ$logPrev)
```
#################################################################
Calculating Moran's I
#################################################################
Steps:
1. Generate a distance matrix
2. take inverse of the matrix values
and replace the diagonal entries with zero
3. repeat for each virus
```{r}
#For DWV:
DWV.dists <- as.matrix(dist(cbind(SpatDWV$long, SpatDWV$lat)))
DWV.dists.inv <- 1/DWV.dists
diag(DWV.dists.inv) <- 0
DWV.dists.inv[1:5, 1:5]
DWV.dists.inv <- 1/DWV.dists
diag(DWV.dists.inv) <- 0
DWV.dists.inv[1:5, 1:5]
#For BQCV:
BQ.dists <- as.matrix(dist(cbind(SpatBQ$long, SpatBQ$lat)))
BQ.dists.inv <- 1/BQ.dists
diag(BQ.dists.inv) <- 0
BQ.dists.inv[1:5, 1:5]
Moran.I(SpatDWV$logPrev, DWV.dists.inv)
Moran.I(SpatBQ$logPrev, BQ.dists.inv)
####################################################################
# FUNCTION: GetData
# read in a .csv file
# input: csv file
# output: data frame
# ------------------------------------------------------------------
GetData <- function(fileName=NULL) {
if(is.null(fileName)){
dataFrame <- data.frame(ID=1:10,
varA <- runif(10),
varB <- runif(10))
} else {
dataFrame <- read.table(file=fileName,
header=TRUE,
sep=",",
stringsAsFactors=FALSE)
}
return(dataFrame)
}
GetData()
####################################################################
# FUNCTION: CalculateStuff
# fits an ordinary least squares regression
# input: x and y numeric vectors of same length
# output: entire model summary from lm
# ------------------------------------------------------------------
FitRegressionModel <- function(xVar=runif(10),
yVar=runif(10)) {
dataFrame <- data.frame(xVar,yVar)
regModel <- lm(yVar~xVar,data=dataFrame)
return(summary(regModel))
}
FitRegressionModel()
####################################################################
# FUNCTION: SummarizeOutput
# pulls elements from lm model summary list
# input: list from model summary call of lm
# output: vector of regression residuals
# ------------------------------------------------------------------
SummarizeOutput <- function(z=NULL) {
if(is.null(z)) {
z<- summary(lm(runif(10)~runif(10)))
}
return(z$residuals)
}
SummarizeOutput()
####################################################################
# FUNCTION: GraphResults
# graph data and fitted OLS line
# input: x and y vector of numeric. same length
# output: creates graph
# ------------------------------------------------------------------
GraphResults <- function(xVar=runif(10),
yVar=runif(10)) {
dataFrame <- data.frame(xVar,yVar)
plot(y=dataFrame$yVar,
x=dataFrame$xVar,
pch=21,
bg="lightblue",
cex=2)
regModel <- lm(yVar~xVar,data=dataFrame)
abline(regModel)
message("Message: Regression graph created")
}
GraphResults()
GetData()
CalculateStuff()
SummarizeOutput()
GraphResults()
antFile <- "antcounty.csv" # New England ant data
xCol <- 7 # column 7 = latitude centroid of county
yCol <- 5 # column 5 = number of ant species
#-------------------------------------------------------
# Program Body
temp1 <- GetData(fileName = antFile)
setwd("~/CompBio")
# Global Variables
antFile <- "antcounty.csv" # New England ant data
xCol <- 7 # column 7 = latitude centroid of county
yCol <- 5 # column 5 = number of ant species
#-------------------------------------------------------
# Program Body
temp1 <- GetData(fileName = antFile)
antFile <- "antcountydata.csv" # New England ant data
xCol <- 7 # column 7 = latitude centroid of county
yCol <- 5 # column 5 = number of ant species
#-------------------------------------------------------
# Program Body
temp1 <- GetData(fileName = antFile)
x <- temp1[,xCol]
y <- temp1[,yCol]
FitRegressionModel(xVar=x,yVar=y)
temp2 <- FitRegressionModel(xVar=x,yVar=y)
GraphResults(xVar=x, yVar=y)
print(temp3)
temp3 <- SummarizeOutput(temp2)
GraphResults(xVar=x, yVar=y)
print(temp3)
temp2 <- FitRegressionModel(xVar=x,yVar=y)
temp3 <- SummarizeOutput(temp2)
GraphResults(xVar=x, yVar=y)
print(temp2)
5 > 3 & 1!=2
1 == 2 | 1 != 2 # TRUE
a > 4 & b > 4
a <- 1:10
b <- 10:1
a > 4 & b > 4
a > 4 && b > 4
a > 4 || b > 4
a > 4 | b > 4
a > 4 || b > 4
a > 4 & b > 4
# use "long form" of & and | to find the first comparison that can be evaluated as a true, false, and just use that (to get a single value out)
a > 4 && b > 4
# also "long form" of |
a > 4 | b > 4
a > 4 || b > 4
z <- 0
isTRUE(z)
isTRUE(z)
z <- 1
isTRUE(z)
z <- 1
isTRUE(z)
z <- 4
isTRUE(z)
a <- c(0,0,1)
b <- c(0,1,1)
a | b
xor(a,b)
a <- 1:7
b <- 5:10
# union for all elements
union(a,b)
a <- 1:7
b <- 5:10
# union for all elements
union(a,b)
intersect(a,b)
setequal(a,b)
setdiff(a,b)
setdiff(b,a)
# set equal to check for identical elements
setequal(a,b)
z <- matrix(1:12,nrow=4,byrow=TRUE)
z1 <- matrix(1:12, nrow=4, byrow=FALSE)
z <- matrix(1:12,nrow=4,byrow=TRUE)
z1 <- matrix(1:12, nrow=4, byrow=FALSE)
z==z1
identical(z,z1)
z <- z1
identical(z, z1)
d %in% union(a,b)
d <- 12
z <- signif(runif(1),digits=2)
print(z)
z > 0.5
if(z > 0.5) cat(z, "is a bigger than average number","\n")
if(z > 0.5) cat(z, "is a bigger than average number","\n")
if(z > 0.5) cat(z, "is a bigger than average number","\n")
z <- signif(runif(1),digits=2)
print(z)
z > 0.5
if(z > 0.5) cat(z, "is a bigger than average number","\n")
if(z > 0.8) cat(z,"is a large number", "\n") else
if(z < 0.2) cat(z, "is a small number", "\n") else
{
cat(z,"is an ordinary-sized number", "\n")
cat("z^2 =", z^2, "\n")
}
if(z > 0.8) cat(z,"is a large number", "\n") else
if(z < 0.2) cat(z, "is a small number", "\n") else
{
cat(z,"is an ordinary-sized number", "\n")
cat("z^2 =", z^2, "\n")
}
if( z > 7) print(z)
print(z[z<7])
if(z > 7) print(z)
if(z < 7) print(z)
# use subsetting here
print(z[z<7])
tester <- runif(1000)
eggs <- ifelse(tester>0.35,
rpois(n=1000, lambda=10.2),
0)
head(eggs)
hist(eggs)
