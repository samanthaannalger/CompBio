panel.grid.minor = element_blank (),  # remove minor grid
axis.text = element_blank (),
axis.title = element_blank (),
axis.ticks = element_blank ()
)
.libPaths()
ggmap(vtMap) +
stat_density2d(
aes(x=long, y=lat, fill=..level..),
data=apiaries,
geom="polygon",
bins=20) +
scale_fill_gradient(low="gray", high="red") +
theme(legend.position = "none") +
#Adding points
geom_point(aes(x = long, y = lat), data = apiaries, alpha = .5, color = "blue", size = 1) +
theme( #removing grid lines:
panel.grid.major = element_blank (), # remove major grid
panel.grid.minor = element_blank (),  # remove minor grid
axis.text = element_blank (),
axis.title = element_blank (),
axis.ticks = element_blank ()
)
.libPaths()
library(dismo)
PresPoints<-subset(dbio1, dbio1$fakePres=="Y")
presPoints<-data.frame(lon=PresPoints[,2],lat=PresPoints[,1]) # need to switch order for Maxent
group <- dismo::kfold(presPoints, 5)
pres_train <- presPoints[group != 1, ]
ggmap(vtMap) +
stat_density2d(
aes(x=long, y=lat, fill=..level..),
data=apiaries,
geom="polygon",
bins=20) +
scale_fill_gradient(low = "green", high = "red") +
scale_alpha(range = c(0, 0.3), guide = FALSE) +
#Adding points
geom_point(aes(x = long, y = lat), data = apiaries, alpha = .5, color = "blue", size = 1) +
theme( #removing grid lines:
panel.grid.major = element_blank (), # remove major grid
panel.grid.minor = element_blank (),  # remove minor grid
axis.text = element_blank (),
axis.title = element_blank (),
axis.ticks = element_blank ()
)
ggmap(vtMap) +
stat_density2d(
aes(x=long, y=lat, fill=..level..),
data=apiaries,
geom="polygon",
bins=20) +
scale_fill_gradient(low = "green", high = "red") +
scale_alpha(range = c(0, 0.7), guide = FALSE) +
#Adding points
geom_point(aes(x = long, y = lat), data = apiaries, alpha = .5, color = "blue", size = 1) +
theme( #removing grid lines:
panel.grid.major = element_blank (), # remove major grid
panel.grid.minor = element_blank (),  # remove minor grid
axis.text = element_blank (),
axis.title = element_blank (),
axis.ticks = element_blank ()
)
ggmap(vtMap) +
stat_density2d(
aes(x=long, y=lat, fill=..level..),
data=apiaries,
geom="polygon",
bins=20) +
scale_fill_gradient(low = "green", high = "red") +
scale_alpha(range = c(0, 1), guide = FALSE) +
#Adding points
geom_point(aes(x = long, y = lat), data = apiaries, alpha = .5, color = "blue", size = 1) +
theme( #removing grid lines:
panel.grid.major = element_blank (), # remove major grid
panel.grid.minor = element_blank (),  # remove minor grid
axis.text = element_blank (),
axis.title = element_blank (),
axis.ticks = element_blank ()
)
ggmap(vtMap) +
stat_density2d(
aes(x=long, y=lat, fill=..level..),
data=apiaries,
geom="polygon",
bins=20) +
scale_fill_gradient(low = "green", high = "red") +
#Adding points
geom_point(aes(x = long, y = lat), data = apiaries, alpha = .5, color = "blue", size = 1) +
theme( #removing grid lines:
panel.grid.major = element_blank (), # remove major grid
panel.grid.minor = element_blank (),  # remove minor grid
axis.text = element_blank (),
axis.title = element_blank (),
axis.ticks = element_blank ()
)
ggmap(vtMap) +
stat_density2d(
aes(x=long, y=lat, fill=..level..),
data=apiaries,
geom="polygon",
bins=20) +
scale_fill_gradient(low = "green", high = "red", guide=FALSE) +
#Adding points
geom_point(aes(x = long, y = lat), data = apiaries, alpha = .5, color = "blue", size = 1) +
theme( #removing grid lines:
panel.grid.major = element_blank (), # remove major grid
panel.grid.minor = element_blank (),  # remove minor grid
axis.text = element_blank (),
axis.title = element_blank (),
axis.ticks = element_blank ()
)
vtMap<-get_map(location=c(-72.6954,43.8),zoom=8, scale="auto", source="stamen",maptype="terrain")
ggmap(vtMap)
vtMap<-get_map(location=c(-72.6954,43.8),zoom=8, scale="auto", source="stamen",maptype="terrain")
raster <- ggmap(vtMap) +
stat_density2d(
aes(x=long, y=lat, fill=..level..),
data=apiaries,
geom="polygon",
bins=20) +
scale_fill_gradient(low = "green", high = "red", guide=FALSE) +
#Adding points
geom_point(aes(x = long, y = lat), data = apiaries, alpha = .5, color = "blue", size = 1) +
theme( #removing grid lines:
panel.grid.major = element_blank (), # remove major grid
panel.grid.minor = element_blank (),  # remove minor grid
axis.text = element_blank (),
axis.title = element_blank (),
axis.ticks = element_blank ()
)
raster
vt <- map("state", "VERMONT")
vt
rastervt <- crop(raster, extent(vt))
install.packages(rgdal)
install.packages("rgdal")
install.packages("raster")
install.packages("raster")
library(rgdal)
library(raster)
rastervt <- crop(raster, extent(vt))
rastervt <- crop(raster, vt)
rasterVt <- ggmap(vtMap) +
stat_density2d(
aes(x=long, y=lat, fill=..level..),
data=apiaries,
geom="polygon",
bins=20) +
scale_fill_gradient(low = "green", high = "red", guide=FALSE) +
#Adding points
geom_point(aes(x = long, y = lat), data = apiaries, alpha = .5, color = "blue", size = 1) +
theme( #removing grid lines:
panel.grid.major = element_blank (), # remove major grid
panel.grid.minor = element_blank (),  # remove minor grid
axis.text = element_blank (),
axis.title = element_blank (),
axis.ticks = element_blank ()
)
library(ggmap)
library(ggplot2)
library(maps)
vtMap<-get_map(location=c(-72.6954,43.8),zoom=8, scale="auto", source="google",maptype="satellite")
ggmap(vtMap)
rasterVt <- ggmap(vtMap) +
stat_density2d(
aes(x=long, y=lat, fill=..level..),
data=apiaries,
geom="polygon",
bins=20) +
scale_fill_gradient(low = "green", high = "red", guide=FALSE) +
#Adding points
geom_point(aes(x = long, y = lat), data = apiaries, alpha = .5, color = "blue", size = 1) +
theme( #removing grid lines:
panel.grid.major = element_blank (), # remove major grid
panel.grid.minor = element_blank (),  # remove minor grid
axis.text = element_blank (),
axis.title = element_blank (),
axis.ticks = element_blank ()
)
rasterVt
vt <- map("state", "VERMONT")
vt
rastervt <- crop(rasterVt, vt)
vt <- map("state", "VERMONT")
vt <- ggmap_rast(map = vt)
vt
library(ggmap)
vt <- map("state", "VERMONT")
vt <- ggmap_rast(map = vt)
# Randomization tests
# 11 April 2017
# SAA
# Procedures
# 1) define univariate metric, x
#     (a single number that characterizes a pattern)
# 2) calculate x for observed data x observed
# 3) randomize data subject to some constraints
# 4) calculate x for randomized data, x sim
# 5) repeat (4) many times (n=1000)
#     (generate a distribution of x sim) visualize as a histogram
# 6) compare x observed to x sim
#     p(Xobs|Ho) (probability of x observed, given null hypothesis)
# 7) Draw biological inference
setwd("~/CompBio")
# Compare ant species richness among different New England ecotypes
data <- read.table(file="antcountydata.csv",
header=TRUE,
sep= ",",
stringsAsFactors = FALSE)
data$ecoregion <- as.factor(data$ecoregion) # reclassify existing variable
boxplot(data$n.species~data$ecoregion, col="indianred")
myModel <- aov(n.species~ecoregion, data=data)
summary(myModel)
# define response metric
# use variance among treatment means as X
####################################################################
# FUNCTION: VarMeans
# calculates variance among a group of treatment means
# input: vector of groups, vector of group means
# output: among group variance of means
# ------------------------------------------------------------------
VarMeans <- function(fac=NULL, res=runif(25)) {
if(is.null(fac)){
fac <- as.factor(rep(LETTERS[1:5],each=5))
}
temp <- aggregate(x=res,by=list(fac),FUN=mean)
return(var(temp$x))
# return(var(temp[,2]))
}
VarMeans()
# Specify treatment randomization
###################################################################
# FUNCTION: TreatRan
# randomize treatment (factor) labels
# input: vector of observed treatment labels
# output: vector of randomized treatment labels
# ------------------------------------------------------------------
TreatRan <- function(fac=NULL) {
if(is.null(fac)){
fac <- as.factor(rep(LETTERS[1:5],each=5))
}
fac <- sample(fac, replace=FALSE)
return(fac)
}
TreatRan()
# Now write function for summary and plots
####################################################################
# FUNCTION: randomizeSummary
# give summary stats boxplots, and hisogram plot
# input: vector of simulated values, observed value
# output: list of null model statistics, graphs
# ------------------------------------------------------------------
randomizeSummary <- function(obsX=runif(1),
simX=runif(1000),
fac=NULL,
res=runif(25)) {
if(is.null(fac)) {
fac <- as.factor(rep(LETTERS[1:5],each=5))
}
pLow <- mean(simX <= obsX) # gets the proportion of observed values that are greater or equal to the simulated values
pHigh <- mean(simX >= obsX) # gets the proportion of observed values that are less than or equal to the similared values (tail end)
meanSimX <- mean(simX)
varSimX <- var(simX)
SES <- (obsX = mean(simX))/sd(simX) # if the observed is larger than the simulated, than we will generate a positive value. less than, get a negative value.
outList <- list(stats=list(obsX=obsX,
meanSimX=meanSimX,
varSimX=varSimX,
pLow=pLow,
pHigh=pHigh,
SES=SES,
reps=length(simX)),
raw=simX)
par(mfrow=c(1,3))
# Show boxplot of real data
boxplot(res~fac,col="indianred")
mtext("Observed Data",side=3,font=2,cex=0.75)
# Show boxplot of simulated data
boxplot(res~sample(fac),col="goldenrod")
mtext("Simulated Data",side=3,font=2,cex=0.75)
# Show histogram of simulated and observed values
hist(simX,breaks=25,
col="goldenrod",
main="Null Distribution",
xlab="Simulated Response",
xlim=c(0,max(c(simX,obsX))))
# calculating 95% (and 97.5%) conidence intervals
Interval95 <- quantile(x=simX, prob=c(0.05,0.95))
Interval975 <- quantile(x=simX, prob=c(0.025,0.975))
abline(v=obsX,col="indianred", lwd=2)
abline(v=Interval95,col="black", lwd=2, lty="dotted")
abline(v=Interval975,col="black", lwd=2, lty="dashed")
par(mfrow=c(1,1))
return(outList)
}
z <- randomizeSummary()
#-----------------------------------------
# global variables
filename <- "antcountydata.csv"
data <- read.table(file=filename,
header=TRUE,
sep=",",
stringsAsFactors = FALSE)
data$ecoregion <- as.factor(data$ecoregion)
grps <- data$ecoregion
richness <- data$n.species
nreps <- 1000
outVec <- vector(mode="numeric", length=nreps)
obsX <- VarMeans(fac=grps,res=richness)
runif(1)
runif(5)
replicate(5,runif(3))
outVec <- replicate(nreps,VarMeans(fac=TreatRan(grps),
res=richness))
outVec
head(outVec)
z <- randomizeSummary(obsX=obsX,simX=outVec,fac=grps,
res=richness)
z <- randomizeSummary(obsX=obsX,simX=outVec,fac=grps,
res=richness)
install.packages("popbio")
library(popbio)
stages <- c("Disturbed", "Grassland", "Forest")
A <- matrix(c(0.3, 0.4, 0.3,
0.0, 0.1, 0.2,
0.7, 0.5, 0.5),
nrow=3,
byrow=TRUE, dimnames=list(stages,stages))
n <- c(10,7,3)
timesteps=10
print(A)
MarkovOut <- pop.projection(A=A,n=n,iterations=timesteps)
stage.vector.plot(MarkovOut$stage.vectors,col=2:4)
print(MarkovOut)
##################################################
# function: plotCounts
# plot raw counts of states at each time step
# input: matrix (rows=stages, cols=times)
# output: plot
#-------------------------------------------------
plotCounts <- function(m=matrix) {
par(mfrow=c(1,2))
plot(x=1:ncol(m),
y=m[1,],
type="o",
ylab="Frequency",
xlab="Time",
ylim=c(0,max(m)),
col="red",
lwd=2)
for (i in 2:nrow(m)){
lines(x=1:ncol(m),
y=m[i,],
type="o",
col=i+1,
lty=i,
lwd=2)
}
stage.vector.plot(MarkovOut$stage.vectors,col=2:(nrow(m)+1))
par(mfrow=c(1,1))
}
plotCounts(MarkovOut$stage.vectors)
plotCounts <- function(m=matrix) {
par(mfrow=c(1,2))
plot(x=1:ncol(m),
y=m[1,],
type="o",
ylab="Frequency",
xlab="Time",
ylim=c(0,max(m)),
col="red",
lwd=2)
for (i in 2:nrow(m)){
lines(x=1:ncol(m),
y=m[i,],
type="o",
col=i+1,
lty=i,
lwd=2)
}
stage.vector.plot(MarkovOut$stage.vectors,col=2:(nrow(m)+1))
par(mfrow=c(1,1))
}
plotCounts(MarkovOut$stage.vectors)
0.7, 0.5, 0.1),
tages <- c("Disturbed", "Grassland", "Forest")
A <- matrix(c(0.3, 0.4, 0.3,
0.0, 0.1, 0.2,
0.7, 0.5, 0.1),
nrow=3,
byrow=TRUE, dimnames=list(stages,stages))
n <- c(100,0,0)
timesteps=10
print(A)
MarkovOut <- pop.projection(A=A,n=n,iterations=timesteps)
stage.vector.plot(MarkovOut$stage.vectors,col=2:4)
print(MarkovOut)
##################################################
# function: plotCounts
# plot raw counts of states at each time step
# input: matrix (rows=stages, cols=times)
# output: plot
#-------------------------------------------------
plotCounts <- function(m=matrix) {
par(mfrow=c(1,2))
plot(x=1:ncol(m),
y=m[1,],
type="o",
ylab="Frequency",
xlab="Time",
ylim=c(0,max(m)),
col="red",
lwd=2)
for (i in 2:nrow(m)){
lines(x=1:ncol(m),
y=m[i,],
type="o",
col=i+1,
lty=i,
lwd=2)
}
stage.vector.plot(MarkovOut$stage.vectors,col=2:(nrow(m)+1))
par(mfrow=c(1,1))
}
plotCounts(MarkovOut$stage.vectors)
##################################################
# function: plotCounts
# plot raw counts of states at each time step
# input: matrix (rows=stages, cols=times)
# output: plot
#-------------------------------------------------
plotCounts <- function(m=matrix) {
par(mfrow=c(1,2))
plot(x=1:ncol(m),
y=m[1,],
type="o",
ylab="Frequency",
xlab="Time",
ylim=c(0,max(m)),
col="red",
lwd=2)
for (i in 2:nrow(m)){
lines(x=1:ncol(m),
y=m[i,],
type="o",
col=i+1,
lty=i,
lwd=2)
}
stage.vector.plot(MarkovOut$stage.vectors,col=2:(nrow(m)+1))
par(mfrow=c(1,1))
}
plotCounts(MarkovOut$stage.vectors)
# data from Gotelli N.J. and A.M. Ellison. 2002. Nitrogen deposition and extinction risk in the northern pitcher plant, Sarracenia purpurea. Ecology 83: 2758-2765.
stages <- c("Recruit","Juvenile","NFAdult","FAdult")
timesteps=100
n=c(50,50,50,50)
A <- matrix(c(0,0,0,4,
0.1, 0.854, 0.177, 0,
0, 0.131, 0.708, 0.660,
0,0,0.1,0.307),nrow=4,byrow=TRUE,dimnames=list(stages,stages))
MarkovOut <- pop.projection(A=A,n=n,iterations=timesteps)
plotCounts(MarkovOut$stage.vectors)
A
print(MarkovOut$stage.vectors)
print(MarkovOut$lambda)
print(MarkovOut$stable.stage)
print(head(MarkovOut$pop.sizes))
print(tail(MarkovOut$pop.sizes))
eigen.analysis(A)
stages <- as.character(0:8)
timesteps=150
n= rep(20,9)
A <- matrix(c(0,0,0.646,3,2.17,0,1.054,0,2.214,
0.662,0,0,0,0,0,0,0,0,
0,0.501,0,0,0,0,0,0,0,
0,0,0.756,0,0,0,0,0,0,
0,0,0,0.142,0,0,0,0,0,
0,0,0,0,0.566,0,0,0,0,
0,0,0,0,0,0.026,0,0,0,
0,0,0,0,0,0,0.103,0,0,
0,0,0,0,0,0,0,0,0.000),nrow=9,byrow=TRUE,dimnames=list(stages,stages))
print(A)
plotCounts(MarkovOut$stage.vectors)
MarkovOut <- pop.projection(A=A,n=n,iterations=timesteps)
plotCounts(MarkovOut$stage.vectors)
MarkovOut <- pop.projection(A=A,n=n,iterations=timesteps)
plotCounts(MarkovOut$stage.vectors)
print(MarkovOut$lambda)
print(MarkovOut$stable.stage)
print(head(MarkovOut$pop.sizes))
print(tail(MarkovOut$pop.sizes))
eigen.analysis(A)
# transition matrix from control 5C heated chamber
stages <- c("Empty",paste("Species",LETTERS[1:3]))
timesteps=70
n= rep(20,4)
A <- matrix(c(245,14,8,0,
18,17,0,2,
8,1,0,5,
1,0,0,1) ,nrow=length(stages),byrow=TRUE,dimnames=list(stages,stages))
print(A)
A <- apply(A,2, function(x) x/sum(x)) # convert raw counts to column proportions
print(A)
stages <- c("Empty",paste("Species",LETTERS[1:3]))
timesteps=70
n= rep(20,4)
A <- matrix(c(202,14,13,0,
18,9,2,0,
13,1,35,1,
1,0,0,11) ,nrow=length(stages),byrow=TRUE,dimnames=list(stages,stages))
print(A)
